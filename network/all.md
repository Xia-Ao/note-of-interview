
## OSI（开放系统互联参考模型）标准模型
**物理层**  
负责为数据端设备透明地传输原始比特流，并且定义了数据终端设备和数据通信设备的物理和逻辑链接方法。传输单位是比特。  
协议：RJ45、CLOCK、IEEE802.3   
设备：（中继器，集线器）  
**数据链路层**  
将网络层传下来的IP数据报组装成帧，并检测和矫正物理层产生的传输差错，使得链路对网络层显示一条无差错、可靠的数据传输线路。功能可以概括为成帧，差错控制、流量控制和传输管理。  
物理层面上互连设备之间传送和识别数据帧。**数据帧**和比特流之间的转换。   
协议有：HDLC(高级数据链路控制协议),PPP,STP,SDLC,CSMA(载波监听多路访问)  
设备:（网桥，交换机）  
**网络层**  
负载在网络层上将数据封装成数据报，将数据报从源端传到目的端，同时进行路由选择，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。传输单位数据报。  
将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要**负责寻址和路由选择**。  
协议: IP,ICMP(因特网控制报文协议),IGMP(因特网组管理协议),ARP,RARP,OSPF(开放最短路径优先),IPX  
设备:路由器  
**传输层**  
**负责主机中两个进程之间的通信**，为端到端连接提供可靠的传输服务。为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。  
协议：TCP,UDP  
**会话层**   
会话层允许不同主机上各个进程之间的**会话**，会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要是为表示层实体或用户进程**建立连接**并在连接上提供**有序**地传输数据。  
负责建立和断开通信连接。**通信管理**。  
协议：SQL、RPC(远程调用协议)  
**表示层**  
用于处理两个通信系统中交换信息的表示方式。如数据压缩，加密和解密等。**格式的转化**。    
协议：JPEG、MPEG、ASII    
**应用层**  
是TCP/IP的最高层，它**是直接为应用进程服务的**一层。当不同的应用进程数据通信或数据交换时，就去调用应用层的**不同协议实体**，让这些实体去调用TCP或者UDP层服务来进行网络传输。    
协议：FTP(21) TELNET(23) SMTP(25) DNS(53) TFTP(69) HTTP(80) SNMP(161),DHCP(动态主机配置协议)

## TCP与UDP的区别
1、TCP**面向连接**（如打电话要先拨号建立连接;UDP是无连接的，即发送数据之前不需要建立连接  
2、TCP提供可靠全双功的通信服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按**序**到达,超时重发机制，用塞机制等等;UDP则是不可靠信道，尽最大努力交付，即不保证可靠交付  
3、TCP**面向字节流**，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的．  
4.TCP具有拥塞控制，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）  
5、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信   
6、TCP首部开销20字节;UDP的首部开销小，只有8个字节.  
TCP应用场景：效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。  
UDP应用场景：效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

## TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用
![](https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067)
**三次握手**  
第一次握手：客户机首先向服务器的TCP发送一个连接请求报文段，这个特殊的报文段不含应用层数据，其首部中同步位SYN被设置为1。另外，客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号)；  
第二次握手：服务器的TCP收到连接请求报文段后，如果同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被设置为1，确认号字段值为ack=x+1,并且服务器随机产生起始序号seq=y. 确认包同样不包含应用层数据。  
第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接**分配缓存和变量**。这个报文段的确认为ACK被设置为1，序号段被设置为seq=x+1,确认号字段ack=y+1. 该报文段可以携带数据，如果不携带数据则不消耗序号。  
理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。因为TCP提供全双工通信，因此双方任何时候都可以发送数据。  

**四次挥手**  
第一次挥手：客户机打算关闭连接，就向其TCP发送一个连接释放报文，并停止再发送数据，主动关闭TCP连接。该报文段的FIN标志位被设置为1，seq=u,它等于前面已经发送过的数据的最后一个字节的序号加1。  
第二次挥手：服务器收到连接释放报文段后即发出确认，确认号是ack=u+1,序号为v,等于它前面已经发送过的数据的最后一个字节序号加1.此时客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。ACK=1，seq=v,ack=u+1   
第三次挥手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1，确认号ack= u+1,序号seq =w,已经发送过的数据最后一个字节加1。确认为ACK=1.
(FIN = 1, ACK=1,seq = w, ack =u+1)   
第四次挥手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，确认位ACK=1，序号seq=u+1,确认号ack=w+1. 此时连接还没有释放掉，必须经过实践等待计时器设置的时间2MSL(Max Segment Lifetime),后，客户机才进入连接关闭状态。  
(ACK=1,seq=u+1,ack=w+1)  

https://github.com/jawil/blog/issues/14


## 为什么会采用三次握手，若采用二次握手可以吗？
采用三次握手是为了防止失效的连接请求报文段再次传到服务器，因而产生错误。如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到客服端重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。  
如果只采用一次的话，客户端不知道服务端是否已经收到自己发送的数据，则会不断地发送数据。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手


## 为什么四次挥手，主动方要等待２MSL后才关闭连接．
一、保证TCP协议的全双工连接能够可靠关闭．  
主要为了确保对方能受到ACK信息. 如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。所以，Client不是直接进入CLOSED，而是要保持2MSL,如果在这个时间内又收到了server的关闭请求时可以进行重传，否则说明server已经受到确认包则可以关闭.

##滑动窗口、拥塞控制
**TCP以段为单位发送数据：**在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。理想情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。MSS是在三次握手的时候，在两端主机之间被计算得出。两端主机在发出建立连接的请求时，会在TCP首部写入MSS选项，告诉对方自己的接口能够适应的MSS的大小。然后会在两者之间选择一个较小的值投入使用。  
**利用窗口控制提高速度：**TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样有个缺点，包往返时间越长通信性能就越低。所以引入了窗口的概念，也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。**窗口的大小就是指无需等待确认应答而可以继续发送数据的最大值**。这个机制是使用了大量的缓冲区。在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机得设置缓存保存这些待被重传的数据，直到收到它们的确认应答。  
**窗口控制与重发控制：**首先考虑确认应答未能返回的情况，窗口在一定程度上较大时，即使有少部分的确认应答丢失也不会进行数据重发，可以通过下一个确认应答进行确认。其次，我们来考虑一个某个报文段丢失的情况，发送端会一直收到序号为丢失报文段序号的确认应答，这个确认应答在提醒发送端，我想要接收的是从XXXX开始的数据。而发送端主机如果连续3次收到同一个确认应答，就会将所对应的数据进行重发。这种机制比之前的超时管理更加高效，因此也被称作高速重发控制。  
**流控制：**接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称为窗口大小。窗口大小的值是由接收端主机决定的。TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段值越大，说明网络的吞吐量越高。  
**拥塞控制：**在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。  
首先在TCP要求发送端维护两个窗口：  
1） 接收窗口rwnd，接收方根据当前缓存大小锁许诺的最新窗口值。  
2) 拥塞窗口 cwnd ,发送方根据自己估算的网络拥塞程度而设置的窗口值。  
发送窗口的上限是取这两者的最小值。  
慢开始： TCP刚连接好时，先令拥塞窗口cwnd =1 ,在每次收到一个对新报文段的确认时将cwnd加1. Cwnd的大小呈指数增长。  
拥塞避免算法： 当cwnd大于等于慢启动阈值ssthresh时，cwnd窗口每次加1而不是加倍。当发送方检测到**超时事件**的发生时，就将慢启动阈值设置为当前cwnd的一半，同时将cwnd设置为1. 这样的目的是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。  
快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。  
快恢复：当发送端收到连续三个冗余的ACK时，就执行“乘法减小”算法，把慢启动阈值ssthresh减半，cwnd设置为慢启动阈值减半后的数值（与慢启动不同）。  

## http和https的区别
1. https协议需要到ca申请证书，一般免费证书很少，需要交费。  
2. http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式用的端口也不一样：前者是80，后者是443。  
3. http的连接很简单，是无状态的 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全 HTTPS解决的问题.http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对。**使用SSL在发送方把原始数据进行加密，然后在接受方进行解密保证数据的安全性**

http://www.admin5.com/article/20150708/608526.shtml   


## 电脑上访问一个网页，整个过程是怎么样的
1. **DNS域名解析**  
	在浏览器DNS缓存中搜索  
	在操作系统DNS缓存中搜索  
	读取系统hosts文件，查找其中是否有对应的ip  
	向本地配置的首选DNS服务器发起域名解析请求  
	根DNS服务器，顶级DNS服务区等
2. **建立TCP连接**  
	为了准确地传输数据，TCP协议采用了三次握手策略。发送端首先发送一个带SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有SYN/ACK(acknowledegment)标志的	数据包以示传达确认信息。最后发送方再回传一个带ACK标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP会再次发送相同的数据包。TCP是一个端到端的可靠的面向连接的协议，所	以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。
3. **发起HTTP请求**  
	请求方法：  
	GET:获取资源  
	POST:传输实体主体  
	HEAD:获取报文首部  
	PUT:传输文件  
	DELETE:删除文件  
	OPTIONS:询问支持的方法  
	TRACE:追踪路径  
4. **接受响应结果  **
	状态码：  
	1**：信息性状态码  
	2**：成功状态码  
	200：OK 请求正常处理  
	204：No Content请求处理成功，但没有资源可返回  
	206：Partial Content对资源的某一部分的请求  
	3**：重定向状态码  
	301：Moved Permanently 永久重定向  
	302：Found 临时性重定向  
	304：Not Modified 缓存中读取  
	4**：客户端错误状态码  
	400：Bad Request 请求报文中存在语法错误  
	401：Unauthorized需要有通过Http认证的认证信息  
	403：Forbidden访问被拒绝  
	404：Not Found无法找到请求资源  
	5**：服务器错误状态码  
	500：Internal Server Error 服务器端在执行时发生错误  
	503：Service Unavailable 服务器处于超负载或者正在进行停机维护  
5. **浏览器解析html**
	浏览器按顺序解析html文件，构建DOM树，在解析到外部的css和js文件时，向服务器发起请求下载资源，若是下载css文件，则解析器会在下载的同时继续解析后面的html来构建DOM树，则	在下载js文件和执行它时，解析器会停止对html的解析。这便出现了js阻塞问题。
6. **浏览器布局渲染**
	布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。  
	绘制：将计算好的每个像素点信息绘制在屏幕上

## get提交和post提交的区别
1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。  
　　(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。  
　　(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。  
2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。  
3.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连.POST把提交的数据则放置在是HTTP包的包体中。  
4.GET安全性较低，POST安全性较高。因为GET在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。  
5.get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。  
6.在FORM（表单）中，Method默认为"GET"  

幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。  
　　幂等有一下几种定义：  
　　对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。  
　　对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。  
详见: http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html
http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html

## 重定向和转发的区别
request.getRequestDispatcher("new.jsp").forward(request, response);//转发到new.jsp  
response.sendRedirect("new.jsp");//重定向到new.jsp  
**转发是服务器行为，重定向是客户端行为。**  
转发过程：客户浏览器发送http请求----》web服务器接受此请求--》调用内部的一个方法在容器内部完成请求处理和转发动作----》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。  
重定向过程：客户浏览器发送http请求----》web服务器接受后发送302状态码响应及对应新的location给客户浏览器--》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址----》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。  
重定向，其实是两次request, 第一次，客户端request   A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。  
请求转发是服务器内部把对一个request/response的处理权，移交给另外一个对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。 传输的信息不会丢失。  

##Servlet、Session、Cookie
**Servlet：**Servlet是J2EE规范中的一种，主要是为了扩展java作为web服务的功能。它的作用就是为Java程序提供一个统一的web应用的规范，方便程序员统一地使用这种规范来编写程序。应用容器可以使用提供的规范来实现自己的特性。比如tomcat和jetty代码就不一样是吧，但作为程序员你只需要了解servlet规范就可以从request中取值，可以操作session等等。不用在意应用服务器底层的实现的差别来影响开发。  
**Session：**在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。  
**Session和Cookie的主要区别：**Cookie是把用户的数据写给用户的浏览器。Session技术把用户的数据写到用户独占的session中。Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。  
**服务器是如何实现一个session为一个用户浏览器服务的**服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。  

## RESTFULL风格
Representational State Tranfer   
1. 每个URI代表一种资源  
2. 客户端和服务器之间，传递这种资源的某种表现层。  
3. 客户端通过四个HTTP动词，对服务端资源进行操作，实现表现层转化。  

早期的WEB MVC框架设计者们没有意识地将URL当作抽象资源来看待和设计。所以导致一个比较严重的问题：传统的Web MVC框架基本上只支持GET和POST两种HTTP，而不支持PUT和DELTE,随着框架发展，出现REST，一套支持HTTP规范的新风格。

