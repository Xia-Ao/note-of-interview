## 使用Redis的好处
1. 速度快，数据存储在内存中，查找和操作的时间复杂度都是0（1）
2. 支持丰富数据类型：字符串、列表、集合、散列、有序集合
3. 支持事务，操作都是原子性（要么全部执行，要么全不执行）
4. 丰富的特性：可用于缓存、消息队列、按key设置timeout

## redis相比memcached有什么优势
1. memcached所有的值都是简单的字符串，redis作为其代替者，支持更丰富的数据类型
2. redis速度比memcached快很多
3. redis可以持久化其数据

## mySQL里有2000w数据，redis中只能存20w的数据，如何保证redis中的数据都是热点数据

**Redis内存淘汰机制**：Redis内存淘汰指的是用户存储的一些键被可以被Redis主动地从实例中删除，从而产生读miss的情况，那么Redis为什么要有这种功能？为了更好地使用内存，用一定的缓存miss来换取内存的使用效率。  

	# maxmemory <bytes>
- 客户端发起了需要申请更多内存的命令（如set）。
- Redis检查内存使用情况，如果已使用的内存大于maxmemory则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。
- 如果上面都没问题，则这个命令执行成功。  

**内存淘汰策略**：其中默认的策略为noeviction策略  
	
	# maxmemory-policy noeviction

- noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。
- allkeys-lru：在主键空间中，优先移除最近未使用的key。
- volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。
- allkeys-random：在主键空间中，随机移除某个key。
- volatile-random：在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。

设置了过期时间的键会存放到另一张哈希表中，设置了过期时间的键空间是主键空间的子集。下面分析下上述淘汰策略的应用场景：  
allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。  
allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。  
volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。  

## 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。（KEYS h*llo 匹配 hllo 和 heeeeello 等）   
对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？  
这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

SCAN 每次执行都只会返回少量元素，所以可以用于生产环境，而不会出现像 KEYS 或者 SMEMBERS 命令带来的可能会阻塞服务器的问题。SCAN命令是一个基于游标的迭代器。以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。

## Redis如何做持久化的？
**快照持久化**：Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。BGSAVE来创建一个快照，Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。SAVE来创建一个快照，Redis服务器在快照创建完毕之前将不再响应任何其他命令。再使用快照持久化来保存数据时，一定要记住：如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。

**AOF持久化**：（append-only file）AOF持久化会将被执行的写命令写入到AOF文件的末尾，以此来记录数据发生的变化。appendfsync always表示每个Redis写命令都要同步写入硬盘。这样做会严重降低Redis的速度。 appendfsync everysec表示每秒执行一次同步，显式地将多个写命令同步到硬盘。BGREWRITEAOF用来重写／压缩AOF文件。

bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。

对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

对方追问BGSAVE的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指Redis通过创建子进程来进行BGSAVE操作，cow指的是copy on write，写时复制：继续提供服务，只有当有人修改当前内存数据时，才去复制被修改的内存页，用于生成快照。所有Redis的RDB快照时精准的，精准到执行时刻的状态，因为使用了Copy-On-Write技术。

## Redis主从复制
redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。

主从复制的过程：
  
1. 当一个从数据库启动时，会向主数据库发送sync命令。
2. 主数据库接收到sync命令后开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令。
3. 当快照完成后，主数据库会将快照文件和所有缓存的命令依次发送给从数据库。
4. 从数据库收到后，先清空原有的所有数据，再载入新发来的快照文件，以及执行新发来的缓冲区里的写命令。
5. 之后主数据库的写命令都会同步到从数据库。

配置Redis主从结构（一主多从）：   
通过redis-cli 连接到从节点服务器，执行下面命令即可。  

	slaveof 192.168.33.130 6379

注意点：如果你使用主从复制，那么要确保你的master激活了持久化，或者确保它不会在当掉后自动重启。  
原因：slave是master的完整备份，因此如果master通过一个空数据集重启，slave也会被清掉。   
如果master没有激活持久化，突然master宕机了，不可立即重启master，正确做法应该是：在slave下执行save生成快照，再拷到master路径下，启动master。

## Redis集群
redis集群是一个无中心的分布式Redis存储架构，可以在多个节点之间进行数据共享，解决了Redis高可用、可扩展等问题。redis集群提供了以下两个好处  

1. 将数据自动切分(split)到多个节点。
2. 当集群中的某一个节点故障时，redis还可以继续处理客户端的请求。

一个 Redis 集群包含 16384 个哈希槽（hash slot），数据库中的每个数据都属于这16384个哈希槽中的一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽。集群中的每一个节点负责处理一部分哈希槽。

集群中的每个节点都有1个至N个复制品，其中一个为主节点，其余的为从节点，如果主节点下线了，集群就会把这个主节点的一个从节点设置为新的主节点，继续工作。这样集群就不会因为一个主节点的下线而无法正常工作。

注意点：

1. 如果某一个主节点和他所有的从节点都下线的话，redis集群就会停止工作了。redis集群不保证数据的强一致性，在特定的情况下，redis集群会丢失已经被执行过的写命令
2. 使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因，有时候由于网络原因，如果网络断开时间太长，redis集群就会启用新的主节点，之前发给主节点的数据就会丢失。
