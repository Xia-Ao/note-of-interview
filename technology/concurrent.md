## 多台服务器下，session同步的问题
问题描述：用户在一号机登陆的时候产生了session，用户请求二号机的时候没有session了，把用户踢掉了。

一般有三种解决方案：  

1. 可以把用户的session放在cookie中。  
	优点：解决了session不同步的问题。
	缺点：session放在浏览器中，是不安全的。cookie存储数据的大小是受限制的。移动互联网的发展，还得兼顾移动端session需求。
2. 可以把用户的session持久化到数据库中。
	优点：解决了session不同步的问题，宕机时不易丢失。
	缺点：网站是一个成千上万用户的网站，如果把session放在数据库中，会造成数据库压力太大，从而使得网站不能正常运行。系统的整体吞吐量将受到很大的影响。
3. 可以把用户的session放在缓存服务器中。
	 最好的解决方案就是放在缓存服务器中，可以保证较高的读写性能，对于高并发是非常重要的，且从安全性考虑，session毕竟是有时效性的，使用缓存存储也便于利用缓存的失效机制。  
	 缺点是一旦缓存重启，里面保存的会话就会丢失，需要用户重新建立会话。
	 
缓存服务器集群是通过前端保证的，对缓存的hash值取模来找到对应的缓存服务器，这里用到了一致性哈希算法。 后端服务器将sessionid作为key从分布式缓存中得到对应的session，执行完毕之后再写入分布式缓存中。  

##秒杀问题（高并发+超卖）
前端限流，尽量使用静态页面，采用CDN内容分发服务器减少对核心服务器的负载压力。

数据库事务隔离级别提高到最高级别。悲观锁，数据库锁机制，数据库行锁，可能会导致相互锁死的情况。利用数据库的事务特性，在扣减库存之前，先查看库存数。总之，这样的方式数据库的负载过大，io性能过低。   
直接利用redis的原子性，在缓存里减库存数，但有问题。  
利用redis的队列，将先进来的10个人存入队列当中，rpush，lpop，将其他人拒之门外。  
将提交操作变成两段式，先申请后确认。然后利用Redis的原子自增操作（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。   

https://www.cnblogs.com/billyxp/p/3701124.html