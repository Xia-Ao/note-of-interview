## 数据库事务属性
事务是由一组SQL语句组成的逻辑处理单元，事务是一个不可分割操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务具有以下4个属性，通常简称为事务的ACID属性。  
**原子性**（Atomicity）：原子性是指事务包含的所有操作要么**全部成功**，要么**全部失败回滚**。 因此，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不会对数据库有任何影响，也就是说，**事务是应用中不可再分的最小逻辑执行体**。  
**一致性**（Consistency）：一致性是指事务执行的结果必须使数据库从一种一致性状态变到另一种一致性状态，也就是说，一个事务执行之前和执行之后数据库都必须处于**一致性状态**。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。  
**隔离性**（Isolation）：**隔离性是指并发执行的事务之间不能相互影响**。也就是说，对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。  
**持久性**（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是**永久性**的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。换句换说，事务一旦提交，对数据库所做的任何改变都要记录到永久的存储器中(通常就是保存到物理数据库)。

## 脏读、不可重复读和幻读
事务的**隔离性**主要用于解决事务的并发安全问题，那么有哪些并发安全问题呢？  
1. **脏读**: 脏读是指在**一个事务处理过程中读取了另一个事务未提交的数据**。比如，当一个事务正在多次修改某个数据，而当这个事务对数据的修改还未提交时，这时一个并发的事务来访问该数据，就会造成数据的脏读。（一个事务读取了另一个事务未提交的数据）。特别地，当隔离级别设置为 Read Committed 时，就可以避免脏读，但是仍可能会造成不可重复读。特别地，大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。  
2. **不可重复读**：对于数据库中的某个数据，**一个事务范围内多次查询却返回了不同的数据值**，这是由于在查询间隔该数据被另一个事务修改并提交了。例如，事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务，当事务T1再次读取该数据就得到了不同的结果，即发生了不可重复读。**不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据**。当隔离级别设置为Repeatable read时，可以避免不可重复读。  
3. **幻读**：幻读是事务非独立执行时发生的一种现象，即在一个事务读的过程中，**另外一个事务可能插入了新数据记录，影响了该事务读的结果**。例如，事务 T1 对一个表中所有的行的某个数据项执行了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。这时，操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。**幻读和不可重复读都是读取了另一条已经提交的事务（这点与脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是数据记录插入/删除问题，二者关注的问题点不太相同**。当隔离级别设置为Serializable(最高的事务隔离级别)时，不仅可以避免脏读、不可重复读，还可以避免幻读。但同时代价也花费最高，性能很低，一般很少使用，因为在该级别下并发事务将串行执行。   
总结：脏读关注的是事务读取了另一个事务未提交的数据；不可重复读关注的是同一事务中对同一个数据项多次读取的结果互不相同；幻读更侧重于数据记录的插入/删除问题，比如同一事务中对符合同一条件的数据记录的多次查询的结果互不相同。更进一步地说，不可重复读关注的是数据的更新带来的问题，幻读关注的是数据的增删带来的问题。

## 事务隔离机制
不同数据库的事务隔离级别不尽相同。比如我们在上一节提到，MySQL数据库支持下面的四种隔离级别，并且默认为 Repeatable read 级别；而在Oracle数据库中，只支持Serializable 级别和 Read committed 这两种级别，并且默认为 Read committed 级别。MySQL数据库为我们提供了四种隔离级别，分别为：  
Serializable (串行化)：最高级别，可避免脏读、不可重复读、幻读的发生；  
Repeatable read (可重复读)：可避免脏读、不可重复读的发生；  
Read committed (提交读)：可避免脏读的发生；  
Read uncommitted (未提交读)：最低级别，任何情况都无法保证  

	  		  脏读	不可重复读	幻读
	未提交读  YES	YES		   YES		  
	提交读    NO	YES		   YES		   
	可重复读  NO	NO		   YES		   
	串行化   NO	NO		   NO		   

## 乐观锁，悲观锁
**悲观锁**:它指的是对数据被外界修改持保守(悲观)态度，因此，在整个数据处理过程中，**将数据处于锁定状态**。悲观锁的实现往往依靠数据库提供的锁机制，也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。和乐观锁相比，悲观锁则是一把真正的锁了，它通过SQL语句“select for update”锁住select出的那批数据，这时如果其他事务来更新这批数据时会等待。
**悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证**。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。  
**乐观锁**，虽然名字中带“锁”，但是乐观锁并不锁住任何东西，**而是在提交事务时检查这条记录是否被其他事务进行了修改：如果没有，则提交；否则，进行回滚**。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。如果并发的可能性并不大，那么乐观锁定策略带来的性能消耗是非常小的。乐观锁采用的实现方式一般是记录数据版本。数据版本是为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。一般地，实现数据版本有两种方式，一种是使用版本号，另一种是使用时间戳。    
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作    
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。    
悲观锁是利用数据库本身提供的锁机制来实现的；而乐观锁则是通过记录数据版本实现的   
悲观锁主要用于数据争用激烈的环境或者发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中；而乐观锁主要应用于并发可能性并不太大、数据竞争不激烈的环境中，这时乐观锁带来的性能消耗是非常小的；    
乐观锁不能解决脏读问题，而悲观锁则可以。






--------------------------------


## 手写一段sql语句，具体内容忘了，好像和limit有关

## 存储引擎的区别
**InnoDB**: 支持事务，是面向在线事务处理(OLTP)的应用,特点是行锁设计，支持外键，并支持一致性非锁定读，即默认情况下读取操作不会产生锁．是默认的**存储引擎**:．还提供了插入缓冲，二次写，自适应哈希索引，预读等高性能和高可用的功能．
**MyISAM**: 不支持事务，是表锁设计和支持全文索引，主要面向一些OLAP的数据库应用.它的缓冲池只缓冲索引文件，而不缓冲数据文件．该存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件.
**NDB**:是一个集群存储引擎，其特点是数据全部放在内存中，因此主键查找速度极快，并通过添加NDB数据库存储节点可以线性提高数据库性能，是高可用，高性能的集群系统．
**Memory**: 将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据库都将消失，它非常适合存储临时数据的临时表．默认采用哈希索引．
**Archive**: 只支持INSERT和SELECT操作，使用zlib算法将数据行进行压缩，压缩比可以达到1:10，非常适合存储归档数据.但其本身不是事务安全的存储引擎，其设计目标是提供高速的插入和压缩功能．
**Federated**: 并不存放数据，它只是指向一台远程MySQL数据库服务器上的表.
**Maria存储引擎**:　设计目标主要是用来取代原有的MyISAM存储引擎．

## MyISAM和InnoDB的区别
1. MyISAM是非事务安全型的，而InnoDB是事务安全型的。
2. MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
3. MyISAM支持全文索引，而Innodb不支持全文索引
4. MyISAM表是保存成文件形式的，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。
5. InnoDB表比MyISAM表更安全，可以保证数据不丢失的情况下，切换非事务表到事务表

应用场景
1. MyISAM 管理非事务表，它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
2. InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB,这样可以提高多用户并发操作的性能。

### sql注入原理 
就是通过把SQL命令插入到Web 表单 提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令
1.猜表名，列名等
2.后台身份验证绕过漏洞 
验证绕过漏洞就是'or'='or'后台绕过漏洞，利用的就是AND和OR的运算规则，从而造成后台脚本逻辑性错误.

防范：
1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。
3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。 

## 数据库范式
**第一范式（1NF）：属性不可分**。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。
**第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码（也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中）**。
**第三范式（3NF）：符合2NF，并且，消除传递依赖（每一列数据都和主键直接相关，而不能间接相关）**。 
BCNF:符合3NF,并且,没有任何属性完全函数依赖于非码的任何一组属性.
找个例子说.

参考： http://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html
http://blog.sina.com.cn/s/blog_46d817650100yj2i.html

## 数据库索引
索引是一个单独存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针，使用索引可以提高数据库特定数据的查询速度.索引时在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同,并且每种存储引擎也不一定支持所有索引类型．

索引的存储类型有两种：BTREE和HASH,具体和表的存储引擎有关．MyISAM和InnoDB存储引擎只支持BTREE;MEMORY/HEAD存储索引可以支持HASH和BTREE索引．
**索引的优点**:
1. 通过创建唯一索引，可以保证数据库表中每行数据的唯一性.
2. 可以加快数据的查询速度．
3. 在实现数据的参考完整性方面，可以加速表和表之间的连接．
4. 再使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
5. 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。


**索引的缺点**：
1. 创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加．
2. 索引需要占空间内存．
3. 在对表中数据进行增加,删除和修改的时候，索引也需要动态维护，这样降低了数据维护速度．

### 索引分类
1. 普通索引和唯一索引
2. 直接创建索引和间接创建索引
3. 普通索引和唯一性索引
4. 单个索引和符合索引
5. 聚簇索引和非聚簇索引

## 索引失效？？
1. WHERE字句的查询条件里有不等于号（WHERE column!=...），MYSQL将无法使用索引
2. 如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=...），MYSQL将无法使用索引
3. 在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用。
4. 如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE 'abc%',MYSQL将使用索引；如果条件是LIKE '%abc'，MYSQL将不使用索引。
5. 在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。
6. 如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。
7. 如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。
8. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。
9. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引。

http://www.cnblogs.com/hongfei/archive/2012/10/20/2732589.html
http://my.oschina.net/hebad/blog/370815


## 数据库锁机制
数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问，访问变得有序所设计的一种规则。MySQL各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。
- 表级锁定（table-level）：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。表级锁分为读锁和写锁。

- 页级锁定（page-level）：页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。

- 行级锁定（row-level）：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。InnoDB的行级锁同样分为两种，共享锁和排他锁，同样InnoDB也引入了意向锁（表级锁）的概念，所以也就有了意向共享锁和意向排他锁，所以InnoDB实际上有四种锁，即共享锁（S）、排他锁（X）、意向共享锁（IS）、意向排他锁（IX）；
在MySQL数据库中，使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎，而使用行级锁定的主要是Innodb存储引擎和NDBCluster存储引擎，页级锁定主要是BerkeleyDB存储引擎的锁定方式。

而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。
 	

| 	        | 共享锁（S）| 排他锁（X）| 意向共享锁（IS）| 意向排他锁（IX）|
共享锁（S）	| 兼容	    | 冲突       | 兼容            |冲突
排他锁（X）	| 冲突	    | 冲突       | 冲突            |冲突
意向共享锁（IS） | 兼容      | 冲突       | 兼容            |兼容 
意向排他锁（IX） | 冲突 	    | 冲突       | 兼容            |兼容



参考地址：http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html

MyISAM 表锁优化建议：
1、缩短锁定时间
2、分离能并行的操作
3、合理利用读写优先级




## 数据库事务的几种粒度；

## 是否了解数据库的索引是如何实现的
### MyISAM索引实现
MyISAM索引使用了B+Tree作为索引结构，叶子结点的data域存放的是数据记录的地址。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。主索引和辅助索引的存储结构没有任何区别。
### InnoDB索引实现
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。
第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据。
第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。

### Memory索引实现
Memory索引适用于需要快速访问数据的场景，显示支持哈希索引。内部基于哈希表数据结构实现，只包含哈希值和行指针，对于每一行数据，存储引擎都会对所有的引擎列计算一个哈希码，在哈希表对应位置存放该行数据的指针或地址。为了解决多个hash冲突问题，哈希索引采用了链地址法来解决冲突问题。所以采用链表数组作为存储结构。这种索引结构十分紧凑，且具有很快的查询速度。但也存在一些问题，
1. 哈希表数据不是按照索引顺序存储的，所以无法用于排序。
2. 只能支持等值比较查询。
3. 存在冲突情况下查询速度变慢。
https://msdn.microsoft.com/zh-cn/library/dn133190.aspx

## 数据库连接池原理
### 背景
传统的数据库连接方式是，用户每次请求都要向数据库获取连接，而数据库连接的创建和关闭需要一定的开销。频繁的建立、关闭数据库，会极大的降低系统的性能，增大系统的开销，甚至成为系统的瓶颈。另外使用这种传统的模式，还必须管理数据库的每一个连接，以确保他们能正确关闭，如果出现程序异常而导致某些连接未能关闭。同时无节制的创建连接极易导致数据库服务器内存溢出。

### 原理
数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。以及一套连接使用、分配、管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。

### 开源java连接池:
现在很多Web服务器(Weblogic, WebSphere, Tomcat)都提供了DataSoruce的实现，即连接池的实现。通常我们把DataSource的实现，按其英文含义称之为数据源，数据源中都包含了数据库连接池的实现。
1.C3P0  :是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。参考网站: http://sourceforge.net/projects/c30/
2.Proxool :是一个Java SQL Driver驱动程序，提供了对你选择的其它类型的驱动程序的连接池封装。可以非常简单的移植到现存的代码中。完全可配置。快速，成熟，健壮。可以透明地为你现存的JDBC驱动程序增加连接池功能。  参考网站: http://proxool.sourceforge.net
3.Jakarta DBCP  :是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序用使用。参考网站: http://jakarta.apache.org/commons/dbcp/

原理: http://www.uml.org.cn/sjjm/201004153.asp
实现: http://www.cnblogs.com/lihuiyy/archive/2012/02/14/2351768.html


连接池使用什么数据结构实现
链表

实现连接池: http://www.cnblogs.com/lihuiyy/archive/2012/02/14/2351768.html
四个表 记录成绩，每个大约十万条记录，如何找到成绩最好的同学
servlet的一些相关问题
webservice相关 

## mysql有那些存储引擎，分别有什么特点 






